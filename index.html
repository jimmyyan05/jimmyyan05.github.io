<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <title>菜單</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />

    <!-- jQuery（必須先於 turn.js） -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- turn.js CDN；失敗則載本機 -->
    <script>
      (function () {
        const s = document.createElement("script");
        s.src =
          "https://cdnjs.cloudflare.com/ajax/libs/turn.js/4.1.0/turn.min.js";
        s.onerror = function () {
          const f = document.createElement("script");
          f.src = "lib/turn.min.js";
          document.head.appendChild(f);
        };
        document.head.appendChild(s);
      })();
    </script>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #fbf3ea; /* 外框背景 */
        overflow: hidden;
        font-family: system-ui, "PingFang TC", "Microsoft JhengHei", sans-serif;
      }
      /* #book {
        visibility: hidden;
      } */
      /* 置中舞台：用 flex，不與 turn.js 衝突 */
      .viewport {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      /* 縮放容器：所有縮放/平移都套在這層 */
      .zoom-canvas {
        will-change: transform;
        transform-origin: center center;
      }

      /* 書本本體 */
      #book {
        width: 1060px; /* 530×2 */
        height: 840px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        background: #fbf3ea; /* 書本底色 */
      }

      #book .page {
        width: 530px;
        height: 840px;
        background: #fbf3ea no-repeat center center / 100% 100%;
      }
    </style>
  </head>

  <body>
    <div class="viewport" id="viewport">
      <!-- 縮放畫布：縮放與平移都套在這層 -->
      <div class="zoom-canvas" id="zoomCanvas">
        <div id="book">
          <!-- 依據 pages 資料夾自動產生頁面 -->
          <script>
            (function () {
              // 依pages ASC命名順序列出所有圖片檔案
              var images = [
                "1.jpeg",
                "2.jpeg",
                "3.jpeg",
                "4.jpeg",
                "5.jpeg",
                "6.jpeg",
                "7.jpeg",
                "8.jpeg",
                "9.jpeg",
                "10.jpeg",
                "11.jpeg",
                "12.jpeg",
                "13.jpeg",
                "14.jpeg",
                "15.jpeg",
                "16.jpeg",
                "17.jpeg",
                "18.jpeg",
                "19.jpeg",
                "20.jpeg",
                "21.jpeg",
                "22.jpeg",
                "23.jpeg",
                "24.jpeg",
                "25.jpeg",
                "26.jpeg",
                "27.jpeg",
                "28.jpeg",
                "29.jpeg",
                "30.jpeg",
                "31.jpeg",
                "32.jpeg",
                "33.jpeg",
                "34.jpeg",
                "35.jpeg",
                "36.jpeg",
                "37.jpeg",
                "38.jpeg",
                "39.jpeg",
                "40.jpeg",
                "41.jpeg",
                "42.jpeg",
                "43.jpeg",
                "44.jpeg",
                "45.jpeg",
                "46.jpeg",
                "47.jpeg",
                "48.jpeg",
              ];

              var book = document.getElementById("book");
              if (book) {
                book.innerHTML = "";
                images.forEach(function (img) {
                  var div = document.createElement("div");
                  div.className = "page";

                  //  修BUG(缺頁)：檔名做 URL 編碼，避免括號/空白等特殊字元造成載不到
                  var safeName = encodeURIComponent(img);
                  div.style.backgroundImage = "url('pages/" + safeName + "')";

                  book.appendChild(div);
                });

                //  turn.js 對奇數頁數偶爾會不穩：補一頁空白讓頁數變偶數
                if (images.length % 2 === 1) {
                  var blank = document.createElement("div");
                  blank.className = "page";
                  book.appendChild(blank);
                }
              }
            })();
          </script>
        </div>
      </div>
    </div>

    <script>
      function initWhenReady() {
        if (typeof jQuery === "undefined" || !jQuery.fn)
          return setTimeout(initWhenReady, 50);

        if (typeof jQuery.fn.turn !== "function") {
          return setTimeout(initWhenReady, 100);
        }

        const $book = $("#book");
        const viewport = document.getElementById("viewport");
        const canvas = document.getElementById("zoomCanvas");

        // 初始化翻頁（交給 CSS 置中，所以關掉 autoCenter）
        $book.turn({
          width: 1060,
          height: 840,
          elevation: 50,
          gradients: true,
          autoCenter: false,
        });
        document.getElementById("book").style.visibility = "visible";

        // === 縮放/平移引擎（rAF 平滑 + GPU 加速 + 游標中心縮放）===
        const BASE_W = 1060,
          BASE_H = 840;
        let baseScale = 1; // 視窗自適應倍率
        let scale = 1; // 使用者縮放倍率（MIN..MAX）
        let tx = 0,
          ty = 0; // 平移（視窗中心為原點）
        const MAX_ZOOM = 16,
          MIN_ZOOM = 1;

        //修BUG(自己放大)：避免「連點翻頁」觸發 dblclick 縮放
        // 只允許「雙擊背景」縮放；若想在書上縮放，按住 Shift 再雙擊
        viewport.addEventListener(
          "dblclick",
          function (e) {
            const onBook = !!e.target.closest("#book");
            if (onBook && !e.shiftKey) return;

            const rect = viewport.getBoundingClientRect();
            const cx = e.clientX - rect.left - rect.width / 2;
            const cy = e.clientY - rect.top - rect.height / 2;
            const target = scale > 1.01 ? 1 : 2;
            const sOld = scale,
              sNew = target;

            const contentX = (cx - tx) / (baseScale * sOld);
            const contentY = (cy - ty) / (baseScale * sOld);

            scale = sNew;
            tx = cx - contentX * (baseScale * sNew);
            ty = cy - contentY * (baseScale * sNew);
            schedule();
          },
          { passive: true }
        );

        //  修BUG(自己放大)：阻止頁面 click 冒泡到 viewport（降低被判定成 dblclick 的機率）
        $book.on("click", ".page", function (e) {
          e.stopPropagation();
        });

        // GPU 加速提示
        canvas.style.willChange = "transform";

        function computeBaseScale() {
          baseScale = Math.min(
            viewport.clientWidth / BASE_W,
            viewport.clientHeight / BASE_H,
            1
          );
        }

        function clampPan() {
          const vw = viewport.clientWidth;
          const vh = viewport.clientHeight;
          const cw = BASE_W * baseScale * scale;
          const ch = BASE_H * baseScale * scale;
          const maxX = Math.max(0, (cw - vw) / 2);
          const maxY = Math.max(0, (ch - vh) / 2);
          if (Math.abs(tx) > maxX) tx = tx < 0 ? -maxX : maxX;
          if (Math.abs(ty) > maxY) ty = ty < 0 ? -maxY : maxY;
          if (cw <= vw) tx = 0;
          if (ch <= vh) ty = 0;
        }

        let rafId = 0;
        function applyTransform() {
          rafId = 0;
          clampPan();
          const s = baseScale * scale;
          canvas.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${s})`;
          canvas.classList.toggle("zoomed", scale > 1.001);
        }
        function schedule() {
          if (!rafId) rafId = requestAnimationFrame(applyTransform);
        }

        // 初始化
        function onResize() {
          computeBaseScale();
          schedule();
        }
        window.addEventListener("resize", onResize, { passive: true });
        computeBaseScale();
        schedule();

        // 拖曳平移（放大狀態才啟動）
        let dragging = false,
          sx = 0,
          sy = 0,
          ox = 0,
          oy = 0;
        viewport.addEventListener("pointerdown", (e) => {
          if (scale <= 1.01) return;
          dragging = true;
          sx = e.clientX;
          sy = e.clientY;
          ox = tx;
          oy = ty;
          viewport.setPointerCapture(e.pointerId);
        });
        viewport.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          tx = ox + (e.clientX - sx);
          ty = oy + (e.clientY - sy);
          schedule();
        });
        function endDrag(e) {
          if (!dragging) return;
          dragging = false;
          try {
            viewport.releasePointerCapture(e.pointerId);
          } catch (_) {}
        }
        viewport.addEventListener("pointerup", endDrag);
        viewport.addEventListener("pointercancel", () => (dragging = false));

        // 若仍存在舊的 zoom 按鈕，容錯處理（大多已移除）
        function zoomBy(f) {
          const sOld = scale,
            sNew = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, sOld * f));
          const cx = 0,
            cy = 0; // 以中心
          const contentX = (cx - tx) / (baseScale * sOld);
          const contentY = (cy - ty) / (baseScale * sOld);
          scale = sNew;
          tx = cx - contentX * (baseScale * sNew);
          ty = cy - contentY * (baseScale * sNew);
          schedule();
        }
        ["zoomIn", "zoomOut", "zoomReset"].forEach((id, idx) => {
          const el = document.getElementById(id);
          if (!el) return;
          if (idx === 0) el.onclick = () => zoomBy(1.2);
          if (idx === 1) el.onclick = () => zoomBy(1 / 1.2);
          if (idx === 2)
            el.onclick = () => {
              scale = 1;
              tx = 0;
              ty = 0;
              schedule();
            };
        });

        // 翻頁控制
        document.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") $book.turn("previous");
          if (e.key === "ArrowRight") $book.turn("next");
        });

        //  翻頁點擊（維持你原本邏輯；但已在上面 stopPropagation 了）
        $book.on("click", ".page", function (e) {
          const pageWidth = $(this).width();
          const clickX = e.offsetX;
          if (clickX < pageWidth / 2) {
            $book.turn("previous");
          } else {
            $book.turn("next");
          }
        });
      }
      initWhenReady();
    </script>
  </body>
</html>
